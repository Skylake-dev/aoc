use regex::Regex;
use std::fs;

pub struct Card {
    id: usize, // position + 1
    points: usize,
    number_of_winners: u32,
}

fn get_ints(re: &Regex, text: &str) -> Vec<usize> {
    return re
        .find_iter(text)
        .map(|m| m.as_str())
        .map(|i| i.parse::<usize>().unwrap())
        .collect();
}

fn parse_input(input: &String) -> Vec<Card> {
    let int = Regex::new(r#"[0-9]+"#).unwrap();
    let mut parsed_input: Vec<Card> = Vec::new();
    for line in input.lines() {
        let sep: Vec<&str> = line.split("|").collect();
        let id_and_nums: &str = sep[0];
        let wins: &str = sep[1];
        let id_and_nums_parsed = get_ints(&int, id_and_nums);
        let wins_parsed = get_ints(&int, wins);
        let base: usize = 2;
        let number_of_winners: u32 = id_and_nums_parsed[1..]
            .iter()
            .filter(|x| wins_parsed.contains(x))
            .count()
            .try_into()
            .unwrap();
        let card = Card {
            id: id_and_nums_parsed[0],
            points: if number_of_winners != 0 {
                base.pow(number_of_winners - 1)
            } else {
                0
            },
            number_of_winners: number_of_winners,
        };
        parsed_input.push(card);
    }
    return parsed_input;
}

fn part_1(cards: &Vec<Card>) {
    println!(
        "Total points {}",
        cards.iter().map(|c| c.points).sum::<usize>()
    );
}

// how many cards are generated by the current card
fn win_recursive(curr_card: &Card, cards: &Vec<Card>) -> u32 {
    let mut wins = curr_card.number_of_winners;
    if wins == 0 {
        return 0;
    }
    // the id of the card gives the index of the next
    for i in 0..wins {
        wins += win_recursive(cards.get(curr_card.id + (i as usize)).unwrap(), cards);
    }
    return wins;
}

fn part_2(cards: &Vec<Card>) {
    let mut total_cards = cards.len();
    for card in cards {
        total_cards += win_recursive(card, cards) as usize;
    }
    println!("Total cards {}", total_cards);
}

fn main() {
    let input: String = fs::read_to_string("/home/skylake/aoc2023/inputs/4.txt").unwrap();
    let cards = parse_input(&input);
    part_1(&cards);
    part_2(&cards);
}

// original unoptimized code, with this part 2 takes several seconds because i recount
// the winners every time

// use regex::Regex;
// use std::fs;

// pub struct Card {
//     id: usize, // position + 1
//     numbers: Vec<usize>,
//     winning: Vec<usize>,
// }

// fn get_ints(re: &Regex, text: &str) -> Vec<usize> {
//     return re
//         .find_iter(text)
//         .map(|m| m.as_str())
//         .map(|i| i.parse::<usize>().unwrap())
//         .collect();
// }

// fn parse_input(input: &String) -> Vec<Card> {
//     let int = Regex::new(r#"[0-9]+"#).unwrap();
//     let mut parsed_input: Vec<Card> = Vec::new();
//     for line in input.lines() {
//         let sep: Vec<&str> = line.split("|").collect();
//         let id_and_nums: &str = sep[0];
//         let wins: &str = sep[1];
//         let id_and_nums_parsed = get_ints(&int, id_and_nums);
//         let wins_parsed = get_ints(&int, wins);
//         let card = Card {
//             id: id_and_nums_parsed[0],
//             numbers: id_and_nums_parsed[1..].to_vec(),
//             winning: wins_parsed,
//         };
//         parsed_input.push(card);
//     }
//     return parsed_input;
// }

// fn number_of_winners(card: &Card) -> u32 {
//     let mut i = 0;
//     for num in card.numbers.iter() {
//         if card.winning.contains(&num) {
//             i += 1;
//         }
//     }
//     return i;
// }

// fn part_1(cards: &Vec<Card>) {
//     let mut points: Vec<usize> = Vec::new();
//     let base: usize = 2;
//     for card in cards {
//         let i = number_of_winners(card);
//         if i != 0 {
//             points.push(base.pow(i - 1));
//         }
//     }
//     println!("Total points {}", points.iter().sum::<usize>());
// }

// // how many cards are generated by the current card
// fn win_recursive(curr_card: &Card, cards: &Vec<Card>) -> u32 {
//     let mut wins = number_of_winners(curr_card);
//     if wins == 0 {
//         return 0;
//     }
//     // the id of the card gives the index of the next
//     for i in 0..wins {
//         wins += win_recursive(cards.get(curr_card.id + (i as usize)).unwrap(), cards);
//     }
//     return wins;
// }

// fn part_2(cards: &Vec<Card>) {
//     let mut total_cards = cards.len();
//     for card in cards {
//         total_cards += win_recursive(card, cards) as usize;
//     }
//     println!("Total cards {}", total_cards);
// }

// fn main() {
//     let input: String = fs::read_to_string("/home/skylake/aoc2023/inputs/4.txt").unwrap();
//     let cards = parse_input(&input);
//     part_1(&cards);
//     part_2(&cards);
// }
